!https://github.com/tinkerpop/pipes/raw/master/doc/images/duck-plumber.jpg!

A side-effect based pipe will emit the incoming object unaltered. However, during that process, a computation is effected. This computation can be used to yield a computational side-effect.

h2. Generic SideEffect Pipe

The generic side-effect pipe is @SideEffectClosurePipe@. A @SideEffectClosurePipe@ takes a @PipeClosure@ (see [[Pipe Types]]) that computes on @S@ and emits @S@. However, the provided @PipeClosure@ provides a side-effect computation. An example @PipeClosure@ is provided below:

```java
public class CharTotalPipeClosure extends AbstractPipeClosure<Object,Pipe> {
  
  private final AtomicInteger count;
  
  public CharCountPipeClosure(AtomicInteger count) {
    this.count = count;
  }

  public Object compute(Object... objects) {
     this.count.getAndAdd(((String)objects[0]).length())
     return null;
  }
}
```

When put in the context of a @SideEffectClosurePipe@, the code looks as follows:

```java
AtomicInteger count = new AtomicInteger(0);
Pipe<String, String> pipe = new SideEffectClosurePipe<String>(new CharTotalPipeClosure(count));
pipe.setStarts(Arrays.asList("tell", "me", "your", "name"));
// the results of the iteration are: "tell", "me", "your", "name"
assert count.get() == 14;
```