!https://github.com/tinkerpop/pipes/raw/master/doc/images/plumber-3.png!

There are 4 types of pipes.
  # *Transform*: take an object of type @S@ and emit an object of type @E@.
    ** @Pipe<S,E>@
  # *Filter*: take an object of type @S@ and either emit it or not.
    ** @FilterPipe<S> extends Pipe<S,S>@
  # *Side-Effect*: take an object of type @S@, perform some computation, emit the same object.
    ** @SideEffectPipe<S,T> extends Pipe<S,S>@
  # *Branch*: take an object and select any number of paths to send it down.

The packaging of Pipes is set up such that there is a @transform@, @filter@, @sideeffect@, and @branch@ package. All pipes are instances of one of these 4 types. Moreover, each type has a special "closure"-version known as a @XXXClosurePipe@. For example: @TransformClosurePipe@, @FilterClosurePipe@, and @SideEffectClosurePipe@. These pipes are discussed in their respective sections of the documentation. However, the general description of a @PipeClosure@ is presented here.

h2. Pipe Closures

A "closure":http://en.wikipedia.org/wiki/Closure_(computer_science) is a function that when put within  a second function, is said to "close" the second function. In essence, its a way to make the second function dynamic as the closure provides its "meat."

Pipes has an interface called @PipeClosure<T,P extends Pipe>@ that has the following methods:

```java
public T compute(Object... parameters);
public void setPipe(P hostPipe);
```

A pipe that takes a @PipeClosure@ will use the provided @compute()@ method at a particular point according to the semantics of the pipe. Thus, the JavaDoc of such pipes will articulate the meaning/use of the provided @PipeClosure@. By providing a @P@ @hostPipe@, the @PipeClosure@ can have access to methods provided by the @hostPipe@ that may be useful during the computation. Finally, note that @AbstractPipeClosure@ provides a basic implementation of @setPipe()@ that covers most use cases.